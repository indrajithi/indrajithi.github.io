<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How To Write Production Ready Recursive Queries in PostgreSQL | Indrajith Indraprastham</title><meta name=keywords content><meta name=description content="Recursive queries are typically used to deal with hierarchical or tree-structured data. A common example is when you have a manager > employee relation in a table and you have to construct the organization tree under a manager or find all N level managers of an employee. Strictly speaking, this process is iteration not recursion, but RECURSIVE is the terminology chosen by the SQL standards committee.  PostgreSQL CTE: Common Table Expression From the docs:"><meta name=author content="Indrajith Indraprastham"><link rel=canonical href=https://indrajith.me/posts/production-ready-recursive-queries-in-postgresql/><link crossorigin=anonymous href=/assets/css/stylesheet.min.0a1e554ccf592c7aea3491499fc50f6b1eebbd432b10152f2f456629bc538b9e.css integrity="sha256-Ch5VTM9ZLHrqNJFJn8UPax7rvUMrEBUvL0VmKbxTi54=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://indrajith.me/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://indrajith.me/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://indrajith.me/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://indrajith.me/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://indrajith.me/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.1"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="How To Write Production Ready Recursive Queries in PostgreSQL"><meta property="og:description" content="Recursive queries are typically used to deal with hierarchical or tree-structured data. A common example is when you have a manager > employee relation in a table and you have to construct the organization tree under a manager or find all N level managers of an employee. Strictly speaking, this process is iteration not recursion, but RECURSIVE is the terminology chosen by the SQL standards committee.  PostgreSQL CTE: Common Table Expression From the docs:"><meta property="og:type" content="article"><meta property="og:url" content="https://indrajith.me/posts/production-ready-recursive-queries-in-postgresql/"><meta property="og:image" content="https://indrajith.me/dp.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-14T21:56:55+05:30"><meta property="article:modified_time" content="2022-02-14T21:56:55+05:30"><meta property="og:site_name" content="Indrajith Indraprastham"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://indrajith.me/dp.jpg"><meta name=twitter:title content="How To Write Production Ready Recursive Queries in PostgreSQL"><meta name=twitter:description content="Recursive queries are typically used to deal with hierarchical or tree-structured data. A common example is when you have a manager > employee relation in a table and you have to construct the organization tree under a manager or find all N level managers of an employee. Strictly speaking, this process is iteration not recursion, but RECURSIVE is the terminology chosen by the SQL standards committee.  PostgreSQL CTE: Common Table Expression From the docs:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://indrajith.me/posts/"},{"@type":"ListItem","position":2,"name":"How To Write Production Ready Recursive Queries in PostgreSQL","item":"https://indrajith.me/posts/production-ready-recursive-queries-in-postgresql/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How To Write Production Ready Recursive Queries in PostgreSQL","name":"How To Write Production Ready Recursive Queries in PostgreSQL","description":"Recursive queries are typically used to deal with hierarchical or tree-structured data. A common example is when you have a manager \u0026gt; employee relation in a table and you have to construct the organization tree under a manager or find all N level managers of an employee. Strictly speaking, this process is iteration not recursion, but RECURSIVE is the terminology chosen by the SQL standards committee.  PostgreSQL CTE: Common Table Expression From the docs:","keywords":[],"articleBody":" Recursive queries are typically used to deal with hierarchical or tree-structured data. A common example is when you have a manager  employee relation in a table and you have to construct the organization tree under a manager or find all N level managers of an employee. Strictly speaking, this process is iteration not recursion, but RECURSIVE is the terminology chosen by the SQL standards committee.  PostgreSQL CTE: Common Table Expression From the docs:\n WITH provides a way to write auxiliary statements for use in a larger query. These statements, which are often referred to as Common Table Expressions or CTEs, can be thought of as defining temporary tables that exist just for one query.\n  A common table expression is a temporary result set which you can reference within another SQL statement.\n  A useful property of WITH queries is that they are evaluated only once per execution of the parent query, even if they are referred to more than once by the parent query or sibling WITH queries.\n  Thus, expensive calculations that are needed in multiple places can be placed within a WITH query to avoid redundant work.\n  Another possible application is to prevent unwanted multiple evaluations of functions with side-effects\n Syntax:\nWITH cte_name (column_list) AS ( CTE_query_definition ) statement; Example:\nWITH regional_sales AS ( SELECT region, SUM(amount) AS total_sales FROM orders GROUP BY region ), top_regions AS ( SELECT region FROM regional_sales WHERE total_sales  (SELECT SUM(total_sales)/10 FROM regional_sales) ) SELECT region, product, SUM(quantity) AS product_units, SUM(amount) AS product_sales FROM orders WHERE region IN (SELECT region FROM top_regions) GROUP BY region, product;   The above query has two auxiliary statements named regional_sales and top_regions. The output of regional_sales is used in top_regions and the output of top_region is used in the primary SELECT query. We can write the above query without CTE, but it’d require us to write two levels of nested sub-SELECTs It is easier to follow this way and the auxiliary statements are executed only once although they are referenced multiple times.  RECURSIVE WITH  Using RECURSIVE, a WITH query can refer to its own outupt.  Lets took in to an example which counts from 1 to 50:\nlab=# WITH RECURSIVE cte AS (SELECT 1 AS n -- anchor member UNION SELECT n + 1 -- recursive member FROM cte WHERE n  Let’s create some hierarchial data to play with: CREATE TABLE employees ( id serial PRIMARY KEY, name VARCHAR NOT NULL, manager_id INT ); INSERT INTO employees (id, name, manager_id) VALUES (1, 'Adam Smith', NULL), (2, 'John Nash', 1), (3, 'Mary Jones', 1), (4, 'Peter Gregery', 2), (5, 'Sam Joey', 3), (6, 'Tim Lee', 4), (7, 'Mohan Lal', 5), (8, 'Will Smith', 6), (10, 'Mohan Rathod', 8); Now lets find all the people working under John Nash. WITH RECURSIVE tree as ( SELECT id, name, manager_id from employees where id = 2 UNION SELECT e.id, e.name, e.manager_id from employees as e JOIN tree t ON t.id = e.manager_id ) SELECT id, name, manager_id from tree;\nHere are some links for further reference:\n https://www.postgresqltutorial.com/postgresql-recursive-query/   ","wordCount":"537","inLanguage":"en","datePublished":"2022-02-14T21:56:55+05:30","dateModified":"2022-02-14T21:56:55+05:30","author":{"@type":"Person","name":"Indrajith Indraprastham"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://indrajith.me/posts/production-ready-recursive-queries-in-postgresql/"},"publisher":{"@type":"Organization","name":"Indrajith Indraprastham","logo":{"@type":"ImageObject","url":"https://indrajith.me/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://indrajith.me/ accesskey=h title="< /> (Alt + H)">&lt; /></a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://indrajith.me/>Home</a>&nbsp;»&nbsp;<a href=https://indrajith.me/posts/>Posts</a></div><h1 class=post-title>How To Write Production Ready Recursive Queries in PostgreSQL</h1><div class=post-meta><span title="2022-02-14 21:56:55 +0530 IST">February 14, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Indrajith Indraprastham</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#postgresql-cte-common-table-expression aria-label="PostgreSQL CTE: Common Table Expression">PostgreSQL CTE: Common Table Expression</a></li><li><a href=#recursive-with aria-label="RECURSIVE WITH">RECURSIVE WITH</a></li><li><a href=#lets-create-some-hierarchial-data-to-play-with aria-label="Let&amp;rsquo;s create some hierarchial data to play with:">Let&rsquo;s create some hierarchial data to play with:</a></li><li><a href=#now-lets-find-all-the-people-working-under-john-nash aria-label="Now lets find all the people working under John Nash.">Now lets find all the people working under <code>John Nash</code>.</a></li></ul></div></details></div><div class=post-content><ul><li>Recursive queries are typically used to deal with hierarchical or tree-structured data.</li><li>A common example is when you have a <code>manager > employee</code> relation in a table and you have to construct the organization tree under a manager or find all N level managers of an employee.</li><li>Strictly speaking, this process is iteration not recursion, but <code>RECURSIVE</code> is the terminology chosen by the SQL standards committee.</li></ul><h3 id=postgresql-cte-common-table-expression>PostgreSQL CTE: Common Table Expression<a hidden class=anchor aria-hidden=true href=#postgresql-cte-common-table-expression>#</a></h3><p>From the <a href=https://www.postgresql.org/docs/10/queries-with.html>docs</a>:</p><blockquote><p><code>WITH</code> provides a way to write auxiliary statements for use in a larger query. These statements, which are often referred to as Common Table Expressions or CTEs, can be thought of as defining temporary tables that exist just for one query.</p></blockquote><blockquote><p>A common table expression is a temporary result set which you can reference within another SQL statement.</p></blockquote><blockquote><p>A useful property of <code>WITH</code> queries is that they are evaluated only once per execution of the parent query, even if they are referred to more than once by the parent query or sibling <code>WITH</code> queries.</p></blockquote><blockquote><p>Thus, expensive calculations that are needed in multiple places can be placed within a <code>WITH</code> query to avoid redundant work.</p></blockquote><blockquote><p>Another possible application is to prevent unwanted multiple evaluations of functions with side-effects</p></blockquote><p><strong>Syntax:</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql>  <span style=color:#66d9ef>WITH</span> cte_name (column_list) <span style=color:#66d9ef>AS</span> (
      CTE_query_definition 
  )
  <span style=color:#66d9ef>statement</span>;
</code></pre></div><p><strong>Example:</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>WITH</span> regional_sales <span style=color:#66d9ef>AS</span> (
        <span style=color:#66d9ef>SELECT</span> region, <span style=color:#66d9ef>SUM</span>(amount) <span style=color:#66d9ef>AS</span> total_sales
        <span style=color:#66d9ef>FROM</span> orders
        <span style=color:#66d9ef>GROUP</span> <span style=color:#66d9ef>BY</span> region
     ), top_regions <span style=color:#66d9ef>AS</span> (
        <span style=color:#66d9ef>SELECT</span> region
        <span style=color:#66d9ef>FROM</span> regional_sales
        <span style=color:#66d9ef>WHERE</span> total_sales <span style=color:#f92672>&gt;</span> (<span style=color:#66d9ef>SELECT</span> <span style=color:#66d9ef>SUM</span>(total_sales)<span style=color:#f92672>/</span><span style=color:#ae81ff>10</span> <span style=color:#66d9ef>FROM</span> regional_sales)
     )
<span style=color:#66d9ef>SELECT</span> region,
       product,
       <span style=color:#66d9ef>SUM</span>(quantity) <span style=color:#66d9ef>AS</span> product_units,
       <span style=color:#66d9ef>SUM</span>(amount) <span style=color:#66d9ef>AS</span> product_sales
<span style=color:#66d9ef>FROM</span> orders
<span style=color:#66d9ef>WHERE</span> region <span style=color:#66d9ef>IN</span> (<span style=color:#66d9ef>SELECT</span> region <span style=color:#66d9ef>FROM</span> top_regions)
<span style=color:#66d9ef>GROUP</span> <span style=color:#66d9ef>BY</span> region, product;
</code></pre></div><hr><ul><li>The above query has two auxiliary statements named <code>regional_sales</code> and <code>top_regions</code>.</li><li>The output of <code>regional_sales</code> is used in <code>top_regions</code> and the output of <code>top_region</code> is used in the primary <code>SELECT</code> query.</li><li>We can write the above query without CTE, but it&rsquo;d require us to write two levels of nested <code>sub-SELECTs</code></li><li>It is easier to follow this way and the auxiliary statements are executed only once although they are referenced multiple times.</li></ul><h3 id=recursive-with>RECURSIVE WITH<a hidden class=anchor aria-hidden=true href=#recursive-with>#</a></h3><ul><li>Using <code>RECURSIVE</code>, a <code>WITH</code> query can refer to its own outupt.</li></ul><p>Lets took in to an example which counts from 1 to 50:</p><pre><code>lab=# WITH RECURSIVE  cte
      AS     (SELECT 1 AS n -- anchor member
              UNION
              SELECT n + 1 -- recursive member
              FROM   cte
              WHERE  n &lt; 50 -- terminator
            )
      SELECT n
      FROM   cte;


 n
----
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
</code></pre><hr><h3 id=lets-create-some-hierarchial-data-to-play-with>Let&rsquo;s create some hierarchial data to play with:<a hidden class=anchor aria-hidden=true href=#lets-create-some-hierarchial-data-to-play-with>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> employees (
	id serial <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
	name VARCHAR <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
	manager_id INT
);

<span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> employees (id, name, manager_id) <span style=color:#66d9ef>VALUES</span> 
(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#39;Adam Smith&#39;</span>, <span style=color:#66d9ef>NULL</span>),
(<span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#39;John Nash&#39;</span>, <span style=color:#ae81ff>1</span>),
(<span style=color:#ae81ff>3</span>, <span style=color:#e6db74>&#39;Mary Jones&#39;</span>, <span style=color:#ae81ff>1</span>),
(<span style=color:#ae81ff>4</span>, <span style=color:#e6db74>&#39;Peter Gregery&#39;</span>, <span style=color:#ae81ff>2</span>),
(<span style=color:#ae81ff>5</span>, <span style=color:#e6db74>&#39;Sam Joey&#39;</span>, <span style=color:#ae81ff>3</span>),
(<span style=color:#ae81ff>6</span>, <span style=color:#e6db74>&#39;Tim Lee&#39;</span>, <span style=color:#ae81ff>4</span>),
(<span style=color:#ae81ff>7</span>, <span style=color:#e6db74>&#39;Mohan Lal&#39;</span>, <span style=color:#ae81ff>5</span>),
(<span style=color:#ae81ff>8</span>, <span style=color:#e6db74>&#39;Will Smith&#39;</span>, <span style=color:#ae81ff>6</span>),
(<span style=color:#ae81ff>10</span>, <span style=color:#e6db74>&#39;Mohan Rathod&#39;</span>, <span style=color:#ae81ff>8</span>);
</code></pre></div><h3 id=now-lets-find-all-the-people-working-under-john-nash>Now lets find all the people working under <code>John Nash</code>.<a hidden class=anchor aria-hidden=true href=#now-lets-find-all-the-people-working-under-john-nash>#</a></h3><p>WITH RECURSIVE tree as (
SELECT id, name, manager_id from employees where id = 2
UNION
SELECT e.id, e.name, e.manager_id from employees as e
JOIN tree t
ON t.id = e.manager_id
)
SELECT id, name, manager_id from tree;</p><p>Here are some links for further reference:</p><ol><li><a href=https://www.postgresqltutorial.com/postgresql-recursive-query/>https://www.postgresqltutorial.com/postgresql-recursive-query/</a></li><li></li></ol></div><footer class=post-footer><nav class=paginav><a class=next href=https://indrajith.me/posts/atomic-habits-book-summary/><span class=title>Next Page »</span><br><span>Atomic Habits [Notes]</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://indrajith.me/>Indrajith Indraprastham</a></span>
<span><a href=credits.html>Credits</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>